[
  {
    "projectId": "647f5ab6-4a3c-46b0-815b-2ce5c364f6de",
    "testId": "486be285-da87-40c9-8858-85041b45eb3e",
    "userId": "942894b8-8021-707b-2589-07de5ab04060",
    "title": "TC001-join_cell_with_valid_and_invalid_invite_codes",
    "description": "Test the /api/cells/join POST endpoint to verify that valid invite codes allow users to join a cell successfully, while empty, whitespace, duplicate, or invalid invite codes return appropriate error messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n \n        # -> Input valid user credentials and click login to access the app.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/form/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/form/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/form/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=User successfully joined the cell').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: The user could not join the cell with a valid invite code. The invite code normalization to uppercase or the success response from the API did not occur as expected.')\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/942894b8-8021-707b-2589-07de5ab04060/1765798323305607//tmp/test_task/result.webm",
    "created": "2025-12-15T06:51:34.265Z",
    "modified": "2025-12-15T11:32:05.056Z"
  },
  {
    "projectId": "647f5ab6-4a3c-46b0-815b-2ce5c364f6de",
    "testId": "732d1e86-5002-4b73-8cd7-3ff9ef077703",
    "userId": "942894b8-8021-707b-2589-07de5ab04060",
    "title": "TC002-toggle_bible_translation_between_krv_and_easy",
    "description": "Test the /api/translation PUT endpoint to ensure that switching between KRV and EASY translations updates the verse content and underline states correctly without errors.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n \n        # -> Navigate to the invite code input page or section to input an empty invite code.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/div[2]/div[2]/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Find and navigate to the invite code input field or page to input an empty invite code.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Search for an invite code input field or navigate to the invite code submission page to test empty and whitespace-only invite codes.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Check if there is a menu or navigation element that leads to an invite code submission page or modal, or consider direct API testing for invite code validation.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/header/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Invite Code Accepted').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: The test plan execution failed because submitting an empty or whitespace-only invite code did not return the expected error message indicating the invite code cannot be blank.')\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/942894b8-8021-707b-2589-07de5ab04060/1765798323352455//tmp/test_task/result.webm",
    "created": "2025-12-15T06:51:34.273Z",
    "modified": "2025-12-15T11:32:05.133Z"
  },
  {
    "projectId": "647f5ab6-4a3c-46b0-815b-2ce5c364f6de",
    "testId": "7d656efb-a23b-4484-a1b2-544c9eb84a65",
    "userId": "942894b8-8021-707b-2589-07de5ab04060",
    "title": "TC003-toggle_verse_underline_with_multi_user_support",
    "description": "Test the /api/cells/{cellId}/underlines POST endpoint to verify that underlining a verse toggles correctly, supports multiple users distinctly, prevents duplicate underlines, and updates the state accordingly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n \n        # -> Input valid email and password to log in.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/form/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/form/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('correctpassword')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/form/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Re-enter correct credentials or verify login details before proceeding to test invite code submission.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/form/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/form/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('correctpassword')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/form/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=User successfully joined the cell').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Duplicate invite code submission did not return the expected error indicating the user is already a member of the cell.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/942894b8-8021-707b-2589-07de5ab04060/1765798323381293//tmp/test_task/result.webm",
    "created": "2025-12-15T06:51:34.278Z",
    "modified": "2025-12-15T11:32:05.147Z"
  },
  {
    "projectId": "647f5ab6-4a3c-46b0-815b-2ce5c364f6de",
    "testId": "290ea0c6-35bc-45d6-9bb6-b50f0bfe36f3",
    "userId": "942894b8-8021-707b-2589-07de5ab04060",
    "title": "TC004-cycle_theme_preference_light_dark_system",
    "description": "Test the /api/theme PUT endpoint to confirm that the theme preference cycles through light, dark, and system modes, applies the correct CSS classes, detects OS preference for system mode, and updates the UI without hydration flash.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n \n        # -> Find and navigate to the invite code submission page or interface to input an invalid invite code.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/div[2]/div[2]/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Look for an invite code input field or related UI element to input an invalid invite code.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Look for an API testing interface or developer tools to submit an invalid invite code to the Cell Join API.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/header/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Invite Code Accepted').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Submitting an invalid invite code did not return the expected error response indicating invalid invite code.')\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/942894b8-8021-707b-2589-07de5ab04060/1765798323412951//tmp/test_task/result.webm",
    "created": "2025-12-15T06:51:34.283Z",
    "modified": "2025-12-15T11:32:05.000Z"
  },
  {
    "projectId": "647f5ab6-4a3c-46b0-815b-2ce5c364f6de",
    "testId": "4f8ee5a5-0179-4419-b612-0abb4db1b438",
    "userId": "942894b8-8021-707b-2589-07de5ab04060",
    "title": "TC005-load_todays_reading_plan_with_loading_ui",
    "description": "Test the /api/cells/{cellId}/plan/today GET endpoint to ensure that today's reading plan loads asynchronously with a 500ms delay, displays a loading indicator during fetch, and returns the correct day index, title, passages, and verses based on the current translation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n \n        # -> Input email and password, then click login to enter the main app where Bible translation toggle is available.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/form/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/form/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testpassword')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/div/form/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Translation to EASY successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Bible translation toggle from KRV to EASY did not update the translation state, displayed verses, or underline states as expected.')\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/942894b8-8021-707b-2589-07de5ab04060/1765798323369504//tmp/test_task/result.webm",
    "created": "2025-12-15T06:51:34.289Z",
    "modified": "2025-12-15T11:32:05.144Z"
  }
]
